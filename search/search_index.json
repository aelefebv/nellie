{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Nellie","text":"<p>Nellie is a tool for automated organelle segmentation, tracking, and hierarchical feature extraction in 2D/3D live-cell microscopy.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Segmentation: Automated segmentation of organelles.</li> <li>Tracking: Tracking of organelles over time.</li> <li>Feature Extraction: Hierarchical feature extraction.</li> <li>Napari Plugin: Integration with Napari for visualization.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nellie\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the API Reference for detailed usage information.</p>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the Nellie API documentation. The Nellie package provides a complete pipeline for automated organelle segmentation, tracking, and hierarchical feature extraction in 2D/3D live-cell microscopy.</p>"},{"location":"api/#main-components","title":"Main Components","text":"<ul> <li>Main Interface - Entry point for running the Nellie pipeline</li> <li>Segmentation - Image filtering, labeling, and network analysis</li> <li>Tracking - Object tracking across timepoints</li> <li>Feature Extraction - Hierarchical feature computation</li> <li>Image Info - File handling and metadata management</li> <li>Utilities - Helper functions for logging and GPU operations</li> </ul>"},{"location":"api/#quick-start","title":"Quick Start","text":"<pre><code>from nellie import run\nfrom nellie.im_info import FileInfo\n\n# Load your microscopy image\nfile_info = FileInfo(\"path/to/image.tif\")\n\n# Run the complete Nellie pipeline\nim_info = run(file_info)\n</code></pre>"},{"location":"api/#pipeline-overview","title":"Pipeline Overview","text":"<p>The Nellie pipeline consists of several stages:</p> <ol> <li>Filtering: Multi-scale Frangi filtering for vesselness detection</li> <li>Segmentation: Threshold-based instance segmentation</li> <li>Network Analysis: Skeletonization and topological analysis</li> <li>Marker Detection: Motion capture marker generation</li> <li>Tracking: Temporal tracking using Hu moments and flow interpolation</li> <li>Voxel Reassignment: Frame-to-frame voxel tracking</li> <li>Feature Extraction: Multi-level hierarchical features</li> </ol>"},{"location":"api/feature_extraction/","title":"Feature Extraction","text":"<p>Hierarchical feature extraction for multi-level analysis.</p>"},{"location":"api/feature_extraction/#hierarchical-features","title":"Hierarchical Features","text":"<p>Extract features at multiple levels: voxels, nodes, branches, organelles, and images.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical","title":"hierarchical","text":""},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Hierarchy","title":"Hierarchy","text":"<pre><code>Hierarchy(im_info, skip_nodes=True, viewer=None, use_gpu=True, low_memory=False, enable_motility=True, enable_adjacency=True, device=None, node_chunk_size=None, max_node_mask_elems=int(50000000.0))\n</code></pre> <p>Main orchestration class for hierarchical feature extraction.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>Image metadata object.</p> required <code>skip_nodes</code> <code>bool</code> <p>If True, node-level features are skipped.</p> <code>True</code> <code>viewer</code> <code>optional</code> <p>Viewer object with <code>.status</code> attribute for status updates.</p> <code>None</code> <code>use_gpu</code> <code>bool</code> <p>If True and CuPy is available, some computations will attempt to use GPU. Ignored when device is set to \"cpu\" or \"gpu\".</p> <code>True</code> <code>low_memory</code> <code>bool</code> <p>If True, use low-memory (slower) aggregation strategies where possible.</p> <code>False</code> <code>enable_motility</code> <code>bool</code> <p>If False, skip all motion-related features (flow interpolation, velocities, etc.).</p> <code>True</code> <code>enable_adjacency</code> <code>bool</code> <p>If False, skip adjacency map construction.</p> <code>True</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection for GPU-eligible operations. \"auto\" uses GPU if available.</p> <code>\"auto\"</code> <code>node_chunk_size</code> <code>int</code> <p>Target number of voxels per chunk when assigning voxels to nodes.</p> <code>None</code> <code>max_node_mask_elems</code> <code>int</code> <p>Upper bound on the size of the node/voxel mask (num_nodes * chunk_size).</p> <code>int(50000000.0)</code>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Hierarchy.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main execution method.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Voxels","title":"Voxels","text":"<pre><code>Voxels(hierarchy)\n</code></pre> <p>Voxel-level features.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Nodes","title":"Nodes","text":"<pre><code>Nodes(hierarchy)\n</code></pre> <p>Node-level features.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Branches","title":"Branches","text":"<pre><code>Branches(hierarchy)\n</code></pre> <p>Branch-level features.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Components","title":"Components","text":"<pre><code>Components(hierarchy)\n</code></pre> <p>Component (organelle)-level features.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.Image","title":"Image","text":"<pre><code>Image(hierarchy)\n</code></pre> <p>Image-level aggregated features.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.append_to_array","title":"append_to_array","text":"<pre><code>append_to_array(to_append)\n</code></pre> <p>Convert feature dict into list-of-arrays + headers.</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.create_feature_array","title":"create_feature_array","text":"<pre><code>create_feature_array(level, labels=None)\n</code></pre> <p>Original non-streaming implementation kept for backwards compatibility. Not used inside Hierarchy anymore (which streams to CSV directly).</p>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.aggregate_stats_for_class","title":"aggregate_stats_for_class","text":"<pre><code>aggregate_stats_for_class(child_class, t, list_of_idxs, low_memory=False)\n</code></pre> <p>Aggregate mean/std/min/max/sum over groups of indices for a given class at time t.</p> <p>Parameters:</p> Name Type Description Default <code>child_class</code> <code>object with stats_to_aggregate and per-stat per-frame arrays</code> required <code>t</code> <code>int</code> required <code>list_of_idxs</code> <code>list of 1D index arrays (groups)</code> required <code>low_memory</code> <code>bool</code> <p>If True, use a slower but memory-light implementation.</p> <code>False</code>"},{"location":"api/feature_extraction/#nellie.feature_extraction.hierarchical.distance_check","title":"distance_check","text":"<pre><code>distance_check(border_mask, check_coords, spacing)\n</code></pre> <p>Compute distance from points in check_coords to nearest border point.</p>"},{"location":"api/im_info/","title":"Image Info","text":"<p>File handling and metadata management for microscopy images.</p>"},{"location":"api/im_info/#file-information-and-verification","title":"File Information and Verification","text":"<p>Classes for loading, validating, and managing metadata from various microscopy file formats.</p>"},{"location":"api/im_info/#nellie.im_info.verifier","title":"verifier","text":"<p>File verification and image metadata handling for microscopy images.</p> <p>This module provides FileInfo and ImInfo classes for loading, validating, and managing metadata from various microscopy file formats (TIFF, OME-TIFF, ND2).</p>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo","title":"FileInfo","text":"<pre><code>FileInfo(filepath, output_dir=None, output_naming='detailed')\n</code></pre> <p>A class to handle file information, metadata extraction, and basic file operations for microscopy image files.</p> <p>Attributes:</p> Name Type Description <code>filepath</code> <code>str</code> <p>Path to the input file.</p> <code>metadata</code> <code>dict or None</code> <p>Stores the metadata extracted from the file.</p> <code>metadata_type</code> <code>str or None</code> <p>Type of metadata detected (e.g., 'ome', 'imagej', 'nd2').</p> <code>axes</code> <code>str or None</code> <p>String representing the axes in the file (e.g., 'TZCYX').</p> <code>shape</code> <code>tuple or None</code> <p>Shape of the image file.</p> <code>dim_res</code> <code>dict or None</code> <p>Dictionary of physical dimensions (X, Y, Z, T) resolution in microns or seconds.</p> <code>input_dir</code> <code>str</code> <p>Directory of the input file.</p> <code>basename</code> <code>str</code> <p>Filename with extension.</p> <code>filename_no_ext</code> <code>str</code> <p>Filename without the extension.</p> <code>extension</code> <code>str</code> <p>File extension (e.g., '.tiff', '.nd2').</p> <code>output_dir</code> <code>str</code> <p>Output directory for processed files.</p> <code>output_naming</code> <code>str</code> <p>Output naming strategy (\"detailed\" or \"stable\").</p> <code>nellie_necessities_dir</code> <code>str</code> <p>Directory for internal processing data.</p> <code>ome_output_path</code> <code>str or None</code> <p>Path for OME TIFF output.</p> <code>good_dims</code> <code>bool</code> <p>Whether the dimensional metadata is valid.</p> <code>good_axes</code> <code>bool</code> <p>Whether the axes metadata is valid.</p> <code>ch</code> <code>int</code> <p>Selected channel.</p> <code>t_start</code> <code>int</code> <p>Start timepoint for processing.</p> <code>t_end</code> <code>int or None</code> <p>End timepoint for processing.</p> <code>dtype</code> <code>type or None</code> <p>Data type of the image.</p> <p>Methods:</p> Name Description <code>_find_tif_metadata</code> <p>Extract metadata from TIFF or OME-TIFF files.</p> <code>_find_nd2_metadata</code> <p>Extract metadata from ND2 files.</p> <code>find_metadata</code> <p>Detect file type and extract corresponding metadata.</p> <code>_get_imagej_metadata</code> <p>Extract dimensional resolution from ImageJ metadata.</p> <code>_get_ome_metadata</code> <p>Extract dimensional resolution from OME metadata.</p> <code>_get_tif_tags_metadata</code> <p>Extract dimensional resolution from generic TIFF tags.</p> <code>_get_nd2_metadata</code> <p>Extract dimensional resolution from ND2 metadata.</p> <code>load_metadata</code> <p>Load and validate dimensional metadata based on the file type.</p> <code>_check_axes</code> <p>Validate the axes metadata for correctness.</p> <code>_check_dim_res</code> <p>Validate the dimensional resolution metadata for correctness.</p> <code>change_axes</code> <p>Change the axes string and revalidate the metadata.</p> <code>change_dim_res</code> <p>Modify the resolution of a specific dimension.</p> <code>change_selected_channel</code> <p>Select a different channel in the file for processing.</p> <code>select_temporal_range</code> <p>Select a temporal range for processing.</p> <code>_validate</code> <p>Validate the current state of axes and dimension metadata.</p> <code>read_file</code> <p>Read the image file based on its type.</p> <code>_get_output_path</code> <p>Generate the output file path based on the current axes, resolution, and channel.</p> <code>save_ome_tiff</code> <p>Save the processed image file as an OME-TIFF file with updated metadata.</p> <p>Initializes the FileInfo object and creates directories for outputs if they do not exist.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the input file.</p> required <code>output_dir</code> <code>str</code> <p>Directory for saving output files. Defaults to a subdirectory within the input file's directory.</p> <code>None</code> <code>output_naming</code> <code>str</code> <p>Output naming strategy (\"detailed\" or \"stable\"). Defaults to \"detailed\".</p> <code>'detailed'</code>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.find_metadata","title":"find_metadata","text":"<pre><code>find_metadata()\n</code></pre> <p>Detects file type (e.g., TIFF or ND2) and calls the appropriate metadata extraction method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file type is not supported.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.load_metadata","title":"load_metadata","text":"<pre><code>load_metadata()\n</code></pre> <p>Loads and validates dimensional metadata based on the file type (OME, ImageJ, ND2, or generic TIFF).</p>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.change_axes","title":"change_axes","text":"<pre><code>change_axes(new_axes)\n</code></pre> <p>Changes the axes string and revalidates the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>new_axes</code> <code>str</code> <p>New axes string to replace the existing one.</p> required"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.change_dim_res","title":"change_dim_res","text":"<pre><code>change_dim_res(dim, new_size)\n</code></pre> <p>Modifies the resolution of a specific dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>Dimension to modify (e.g., 'X', 'Y', 'Z', 'T').</p> required <code>new_size</code> <code>float</code> <p>New resolution for the specified dimension.</p> required"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.change_selected_channel","title":"change_selected_channel","text":"<pre><code>change_selected_channel(ch)\n</code></pre> <p>Changes the selected channel for processing.</p> <p>Parameters:</p> Name Type Description Default <code>ch</code> <code>int</code> <p>Index of the new channel to select.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the axes or dimension metadata are invalid.</p> <code>KeyError</code> <p>If no channel dimension is available.</p> <code>IndexError</code> <p>If the selected channel index is out of range.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.select_temporal_range","title":"select_temporal_range","text":"<pre><code>select_temporal_range(start=0, end=None)\n</code></pre> <p>Selects a temporal range for processing.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>Start index of the temporal range. Defaults to 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>End index of the temporal range. Defaults to None, which includes all timepoints.</p> <code>None</code>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.read_file","title":"read_file","text":"<pre><code>read_file()\n</code></pre> <p>Reads the image file into memory, supporting TIFF and ND2 formats.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Numpy array representing the image data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file type is unsupported.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.FileInfo.save_ome_tiff","title":"save_ome_tiff","text":"<pre><code>save_ome_tiff()\n</code></pre> <p>Saves the processed image data as an OME-TIFF file, including updated metadata.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the axes or dimensional resolution metadata is invalid.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.ImInfo","title":"ImInfo","text":"<pre><code>ImInfo(file_info)\n</code></pre> <p>A class to manage image data and file outputs related to microscopy image processing.</p> <p>This class handles the initialization of memory-mapped image data, creation of output paths, extraction of OME metadata, and memory allocation for various stages of an image processing pipeline.</p> <p>Attributes:</p> Name Type Description <code>file_info</code> <code>FileInfo</code> <p>The FileInfo object containing metadata and file paths.</p> <code>im_path</code> <code>str</code> <p>Path to the OME-TIFF image file.</p> <code>im</code> <code>ndarray</code> <p>Memory-mapped image data loaded from the file.</p> <code>screenshot_dir</code> <code>str</code> <p>Directory for saving screenshots of processed images.</p> <code>graph_dir</code> <code>str</code> <p>Directory for saving graphs of processed data.</p> <code>dim_res</code> <code>dict</code> <p>Dictionary storing the resolution of the image along the dimensions (X, Y, Z, T).</p> <code>axes</code> <code>str</code> <p>Axes string representing the dimensions in the image (e.g., 'TZYX').</p> <code>new_axes</code> <code>str</code> <p>Modified axes string if additional dimensions are added.</p> <code>shape</code> <code>tuple</code> <p>Shape of the image data.</p> <code>ome_metadata</code> <code>OME</code> <p>OME metadata object extracted from the image.</p> <code>no_z</code> <code>bool</code> <p>Flag indicating if the Z dimension is absent or has a single slice.</p> <code>no_t</code> <code>bool</code> <p>Flag indicating if the T dimension is absent or has a single timepoint.</p> <code>pipeline_paths</code> <code>dict</code> <p>Dictionary storing output paths for different stages of the image processing pipeline.</p> <p>Methods:</p> Name Description <code>_check_axes_exist</code> <p>Checks if the Z and T dimensions exist and updates the flags <code>no_z</code> and <code>no_t</code> accordingly.</p> <code>create_output_path</code> <p>Creates a file path for a specific stage of the image processing pipeline.</p> <code>_create_output_paths</code> <p>Creates all necessary output paths for various stages in the image processing pipeline.</p> <code>remove_intermediates</code> <p>Removes intermediate files created during the image processing pipeline, except for .csv files.</p> <code>_get_ome_metadata</code> <p>Extracts OME metadata from the image and updates resolution, axes, and shape information.</p> <code>get_memmap</code> <p>Returns a memory-mapped array for the image data from the specified file.</p> <code>allocate_memory</code> <p>return_memmap: bool = False, read_mode: str = 'r+') Allocates memory for new image data, saves it to the specified file, and writes updated OME metadata.</p> <p>Initializes the ImInfo object, loading image data and setting up directories for screenshots and graphs.</p> <p>If the OME-TIFF file does not exist, it creates one by calling <code>save_ome_tiff()</code> from the FileInfo class.</p> <p>Parameters:</p> Name Type Description Default <code>file_info</code> <code>FileInfo</code> <p>An instance of the FileInfo class, containing metadata and paths for the image file.</p> required"},{"location":"api/im_info/#nellie.im_info.verifier.ImInfo.create_output_path","title":"create_output_path","text":"<pre><code>create_output_path(pipeline_path, ext='.ome.tif', for_nellie=True)\n</code></pre> <p>Creates a file path for a specific stage of the image processing pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline_path</code> <code>str</code> <p>A descriptive string representing the stage of the image processing pipeline (e.g., 'im_preprocessed').</p> required <code>ext</code> <code>str</code> <p>The file extension to use (default is '.ome.tif').</p> <code>'.ome.tif'</code> <code>for_nellie</code> <code>bool</code> <p>Whether the output is for internal use by Nellie (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The full file path for the given stage of the image processing pipeline.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.ImInfo.remove_intermediates","title":"remove_intermediates","text":"<pre><code>remove_intermediates()\n</code></pre> <p>Removes intermediate files created during the image processing pipeline, except for CSV files.</p> <p>This method loops through all pipeline paths and deletes files (except .csv files) that were created during processing. It also deletes the main image file if it exists.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.ImInfo.get_memmap","title":"get_memmap","text":"<pre><code>get_memmap(file_path, read_mode='r+')\n</code></pre> <p>Returns a memory-mapped array for the image data from the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the image file to be memory-mapped.</p> required <code>read_mode</code> <code>str</code> <p>Mode for reading the memory-mapped file (default is 'r+').</p> <code>'r+'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A memory-mapped numpy array representing the image data.</p>"},{"location":"api/im_info/#nellie.im_info.verifier.ImInfo.allocate_memory","title":"allocate_memory","text":"<pre><code>allocate_memory(output_path, dtype='float', data=None, description='No description.', return_memmap=False, read_mode='r+')\n</code></pre> <p>Allocates memory for new image data or writes new data to an output file.</p> <p>This method creates an empty OME-TIFF file with the specified <code>dtype</code> and shape, or writes the given <code>data</code> to the file. It also updates the OME metadata with a description and the correct pixel type.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>Path to the output file.</p> required <code>dtype</code> <code>str</code> <p>Data type for the new image (default is 'float').</p> <code>'float'</code> <code>data</code> <code>ndarray</code> <p>Numpy array containing image data to write (default is None, which allocates empty memory).</p> <code>None</code> <code>description</code> <code>str</code> <p>Description for the OME metadata (default is 'No description.').</p> <code>'No description.'</code> <code>return_memmap</code> <code>bool</code> <p>Whether to return a memory-mapped array for the newly allocated file (default is False).</p> <code>False</code> <code>read_mode</code> <code>str</code> <p>Mode for reading the memory-mapped file if <code>return_memmap</code> is True (default is 'r+').</p> <code>'r+'</code> <p>Returns:</p> Type Description <code>(ndarray, optional)</code> <p>A memory-mapped numpy array if <code>return_memmap</code> is set to True.</p>"},{"location":"api/nellie_napari/","title":"Nellie Napari Plugin","text":""},{"location":"api/nellie_napari/#nellie_napari","title":"nellie_napari","text":""},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor","title":"NellieProcessor","text":"<pre><code>NellieProcessor(napari_viewer, nellie, parent=None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>The NellieProcessor class manages the different steps of the Nellie pipeline such as preprocessing, segmentation, mocap marking, tracking, voxel reassignment, and feature extraction. It provides an interface to run each step individually or as part of a full pipeline within a napari viewer.</p> <p>Attributes:</p> Name Type Description <code>nellie</code> <code>object</code> <p>Reference to the Nellie instance managing the pipeline.</p> <code>viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> <code>im_info_list</code> <code>list of ImInfo or None</code> <p>List of ImInfo objects for the selected files. Contains metadata and file information.</p> <code>current_im_info</code> <code>ImInfo or None</code> <p>The current image's information and metadata object.</p> <code>status_label</code> <code>QLabel</code> <p>Label displaying the current status of the process.</p> <code>status</code> <code>str or None</code> <p>The current status of the process (e.g., \"preprocessing\", \"segmentation\").</p> <code>num_ellipses</code> <code>int</code> <p>Counter to manage the ellipsis effect on the status label during execution.</p> <code>status_timer</code> <code>QTimer</code> <p>Timer that periodically updates the status label during pipeline execution.</p> <code>open_dir_button</code> <code>QPushButton</code> <p>Button to open the output directory of the current image file.</p> <code>run_button</code> <code>QPushButton</code> <p>Button to run the full Nellie pipeline.</p> <code>preprocess_button</code> <code>QPushButton</code> <p>Button to run only the preprocessing step of the pipeline.</p> <code>segment_button</code> <code>QPushButton</code> <p>Button to run only the segmentation step of the pipeline.</p> <code>mocap_button</code> <code>QPushButton</code> <p>Button to run only the mocap marking step of the pipeline.</p> <code>track_button</code> <code>QPushButton</code> <p>Button to run only the tracking step of the pipeline.</p> <code>reassign_button</code> <code>QPushButton</code> <p>Button to run only the voxel reassignment step of the pipeline.</p> <code>feature_export_button</code> <code>QPushButton</code> <p>Button to run only the feature extraction step of the pipeline.</p> <code>initialized</code> <code>bool</code> <p>Flag indicating whether the processor has been initialized.</p> <code>pipeline</code> <code>bool</code> <p>Flag indicating whether the full pipeline is being run.</p> <p>Methods:</p> Name Description <code>set_ui</code> <p>Initializes and sets the layout and UI components for the NellieProcessor.</p> <code>post_init</code> <p>Post-initialization method to load image information and check file existence.</p> <code>check_file_existence</code> <p>Checks the existence of necessary files for each step of the pipeline and enables/disables buttons accordingly.</p> <code>run_nellie</code> <p>Runs the entire Nellie pipeline starting from preprocessing to feature extraction.</p> <code>run_preprocessing</code> <p>Runs the preprocessing step of the Nellie pipeline.</p> <code>run_segmentation</code> <p>Runs the segmentation step of the Nellie pipeline.</p> <code>run_mocap</code> <p>Runs the mocap marking step of the pipeline.</p> <code>run_tracking</code> <p>Runs the tracking step of the pipeline.</p> <code>run_reassign</code> <p>Runs the voxel reassignment step of the pipeline.</p> <code>run_feature_export</code> <p>Runs the feature extraction step of the pipeline.</p> <code>set_status</code> <p>Sets the status to indicate that a process has started, and starts the status update timer.</p> <code>update_status</code> <p>Updates the status label with the current process and an ellipsis effect while the process is running.</p> <code>reset_status</code> <p>Resets the status label to indicate that no process is running.</p> <code>turn_off_buttons</code> <p>Disables all buttons to prevent multiple processes from running simultaneously.</p> <code>open_directory</code> <p>Opens the output directory where the current image results are saved.</p> <p>Initialize the NellieProcessor class, setting up the user interface and preparing for running various steps of the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> required <code>nellie</code> <code>object</code> <p>Reference to the Nellie instance that manages the pipeline.</p> required <code>parent</code> <code>QWidget</code> <p>Optional parent widget (default is None).</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.set_ui","title":"set_ui","text":"<pre><code>set_ui()\n</code></pre> <p>Initialize and set the layout and user interface components for the NellieProcessor. This includes the status label, buttons for running individual steps, and the button for running the entire pipeline.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.post_init","title":"post_init","text":"<pre><code>post_init()\n</code></pre> <p>Post-initialization method that checks the state of the selected images. It determines whether the pipeline steps have already been completed and enables/disables the corresponding buttons accordingly.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.check_file_existence","title":"check_file_existence","text":"<pre><code>check_file_existence()\n</code></pre> <p>Check the existence of files required for each step of the pipeline (e.g., preprocessed images, segmented labels). Enables or disables buttons based on the existence of these files.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_preprocessing","title":"run_preprocessing","text":"<pre><code>run_preprocessing()\n</code></pre> <p>Start the preprocessing step and updates the UI to reflect that preprocessing is running. If the full pipeline is running, it automatically proceeds to segmentation after preprocessing is finished.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_segmentation","title":"run_segmentation","text":"<pre><code>run_segmentation()\n</code></pre> <p>Start the segmentation step and updates the UI to reflect that segmentation is running. If the full pipeline is running, it automatically proceeds to mocap marking after segmentation is finished.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_mocap","title":"run_mocap","text":"<pre><code>run_mocap()\n</code></pre> <p>Start the mocap marking step and updates the UI to reflect that mocap marking is running. If the full pipeline is running, it automatically proceeds to tracking after mocap marking is finished.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_tracking","title":"run_tracking","text":"<pre><code>run_tracking()\n</code></pre> <p>Start the tracking step and updates the UI to reflect that tracking is running. If the full pipeline is running, it automatically proceeds to voxel reassignment or feature extraction depending on the settings.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_reassign","title":"run_reassign","text":"<pre><code>run_reassign()\n</code></pre> <p>Start the voxel reassignment step and updates the UI to reflect that voxel reassignment is running. If the full pipeline is running, it automatically proceeds to feature extraction after voxel reassignment is finished.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_feature_export","title":"run_feature_export","text":"<pre><code>run_feature_export()\n</code></pre> <p>Start the feature extraction step and updates the UI to reflect that feature extraction is running.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.turn_off_pipeline","title":"turn_off_pipeline","text":"<pre><code>turn_off_pipeline()\n</code></pre> <p>Turn off the pipeline flag to indicate that the full pipeline is no longer running.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.run_nellie","title":"run_nellie","text":"<pre><code>run_nellie()\n</code></pre> <p>Start the entire Nellie pipeline from preprocessing to feature extraction.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.set_status","title":"set_status","text":"<pre><code>set_status()\n</code></pre> <p>Set the status of the processor to indicate that a process is running, and starts the status update timer.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.update_status","title":"update_status","text":"<pre><code>update_status()\n</code></pre> <p>Update the status label with an ellipsis effect to indicate ongoing processing.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.reset_status","title":"reset_status","text":"<pre><code>reset_status()\n</code></pre> <p>Reset the status label to indicate that no process is running.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.turn_off_buttons","title":"turn_off_buttons","text":"<pre><code>turn_off_buttons()\n</code></pre> <p>Disable all buttons to prevent multiple processes from running simultaneously.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieProcessor.open_directory","title":"open_directory","text":"<pre><code>open_directory()\n</code></pre> <p>Open the output directory of the current image in the system file explorer.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieLoader","title":"NellieLoader","text":"<pre><code>NellieLoader(napari_viewer, parent=None)\n</code></pre> <p>               Bases: <code>QTabWidget</code></p> <p>The main loader class for managing the different stages of the Nellie pipeline within the napari viewer. This class provides a tabbed interface for file selection, processing, visualization, analysis, and settings management.</p> <p>Attributes:</p> Name Type Description <code>home</code> <code>Home</code> <p>The home tab instance, providing an overview of the Nellie pipeline.</p> <code>file_select</code> <code>NellieFileSelect</code> <p>The file selection tab instance, allowing users to select and validate image files.</p> <code>processor</code> <code>NellieProcessor</code> <p>The image processing tab instance, where users can process images through the Nellie pipeline.</p> <code>visualizer</code> <code>NellieVisualizer</code> <p>The visualization tab instance, where processed images can be visualized.</p> <code>analyzer</code> <code>NellieAnalysis</code> <p>The analysis tab instance, enabling users to analyze processed image data.</p> <code>settings</code> <code>Settings</code> <p>The settings tab instance, allowing users to configure various settings for the Nellie pipeline.</p> <code>home_tab, file_select_tab, processor_tab, visualizer_tab, analysis_tab, settings_tab</code> <code>int</code> <p>Integer values representing the index of the respective tabs.</p> <code>im_info</code> <code>ImInfo or None</code> <p>Contains metadata and information about the selected image file.</p> <code>im_info_list</code> <code>list of ImInfo or None</code> <p>A list of ImInfo objects when batch processing is enabled (multiple files).</p> <p>Methods:</p> Name Description <code>add_tabs</code> <p>Adds the individual tabs to the widget.</p> <code>reset</code> <p>Resets the state of the loader, removing and reinitializing all tabs.</p> <code>on_tab_change</code> <p>Slot that is triggered when the user changes the tab.</p> <code>go_process</code> <p>Initializes and enables the processing and visualization tabs for image processing.</p> <p>Initialize the NellieLoader class, creating instances of the individual tabs for home, file selection, processing, visualization, analysis, and settings.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> required <code>parent</code> <code>QWidget</code> <p>Optional parent widget (default is None).</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieLoader.on_version_checked","title":"on_version_checked","text":"<pre><code>on_version_checked(current_version, latest_version)\n</code></pre> <p>Slot called when the version check worker finishes. Update the version info and the Home tab status.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieLoader.add_tabs","title":"add_tabs","text":"<pre><code>add_tabs()\n</code></pre> <p>Add the individual tabs for Home, File validation, Process, Visualize, Analyze, and Settings. Initially disables the Process, Visualize, and Analyze tabs until they are needed.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieLoader.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the state of the loader, reinitializing all tabs. This method is typically called when the user wants to start a new session with a fresh file selection and settings.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieLoader.on_tab_change","title":"on_tab_change","text":"<pre><code>on_tab_change(index)\n</code></pre> <p>Event handler that is triggered when the user changes the active tab. Initializes the Analyze or Visualize tabs if they are selected for the first time, and initializes the Settings tab when selected.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the newly selected tab.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieLoader.go_process","title":"go_process","text":"<pre><code>go_process()\n</code></pre> <p>Prepare the image(s) for processing and visualization. This method is called after a file has been selected and validated. It enables the Process and Visualize tabs and initializes them.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis","title":"NellieAnalysis","text":"<pre><code>NellieAnalysis(napari_viewer, nellie, parent=None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A class for analyzing and visualizing multi-dimensional microscopy data using histograms, graphs, and overlays in the napari viewer.</p> <p>Initialize the NellieAnalysis widget.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>The napari viewer instance.</p> required <code>nellie</code> <code>object</code> <p>The main Nellie plugin instance.</p> required <code>parent</code> <code>QWidget</code> <p>The parent widget, by default None.</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset internal state so the widget can be reused for a new dataset.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.post_init","title":"post_init","text":"<pre><code>post_init()\n</code></pre> <p>Initialize UI elements and connect them to their event handlers. Must be called once after construction, when 'nellie' and 'viewer' are ready.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.set_default_dropdowns","title":"set_default_dropdowns","text":"<pre><code>set_default_dropdowns()\n</code></pre> <p>Set default values for the hierarchy level and attribute dropdowns.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.check_for_adjacency_map","title":"check_for_adjacency_map","text":"<pre><code>check_for_adjacency_map()\n</code></pre> <p>Check whether an adjacency map exists; if not, disable the overlay button.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.rewrite_dropdown","title":"rewrite_dropdown","text":"<pre><code>rewrite_dropdown()\n</code></pre> <p>Update the hierarchy level dropdown based on available data.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.export_data","title":"export_data","text":"<pre><code>export_data()\n</code></pre> <p>Export the current graph data as a CSV file to the graph directory.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.save_graph","title":"save_graph","text":"<pre><code>save_graph()\n</code></pre> <p>Save the current graph as a PNG file to the graph directory.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.on_hist_change","title":"on_hist_change","text":"<pre><code>on_hist_change(event)\n</code></pre> <p>Called when histogram ranges or bin count change.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Any</code> <p>The event that triggered the change (unused).</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.get_index","title":"get_index","text":"<pre><code>get_index(layer, event)\n</code></pre> <p>Retrieve indices of voxel and mapped features based on mouse position.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer that was clicked.</p> required <code>event</code> <code>Any</code> <p>The mouse event containing the position.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.overlay","title":"overlay","text":"<pre><code>overlay()\n</code></pre> <p>Apply an overlay of attribute data onto the image in the napari viewer, using adjacency maps to map higher-level features to voxels.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.on_t_change","title":"on_t_change","text":"<pre><code>on_t_change(event)\n</code></pre> <p>Called when the current timepoint changes in the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Any</code> <p>The event that triggered the change.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.toggle_match_t","title":"toggle_match_t","text":"<pre><code>toggle_match_t(state)\n</code></pre> <p>Toggle whether to pool across all timepoints or use the current one.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>The state of the checkbox (Qt.Checked or Qt.Unchecked).</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.toggle_mean_med","title":"toggle_mean_med","text":"<pre><code>toggle_mean_med(state)\n</code></pre> <p>Toggle between mean/std view and median/quartiles.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>The state of the checkbox (Qt.Checked or Qt.Unchecked).</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.get_csvs","title":"get_csvs","text":"<pre><code>get_csvs()\n</code></pre> <p>Load all feature CSVs into DataFrames.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.on_level_selected","title":"on_level_selected","text":"<pre><code>on_level_selected(index)\n</code></pre> <p>Called when a hierarchy level is selected from the dropdown.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the selected item.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.on_attr_selected","title":"on_attr_selected","text":"<pre><code>on_attr_selected(index)\n</code></pre> <p>Called when a feature (base attribute) is selected from the dropdown.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the selected item.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.on_form_selected","title":"on_form_selected","text":"<pre><code>on_form_selected(index)\n</code></pre> <p>Called when a statistic form (mean, std, min, max, ...) is selected.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the selected item.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.get_stats","title":"get_stats","text":"<pre><code>get_stats()\n</code></pre> <p>Compute basic statistics (mean/std or quartiles) for current attribute.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.draw_stats","title":"draw_stats","text":"<pre><code>draw_stats()\n</code></pre> <p>Draw statistics on the histogram plot.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.plot_data","title":"plot_data","text":"<pre><code>plot_data(title)\n</code></pre> <p>Plot the currently selected attribute data as a histogram.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title for the plot.</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieAnalysis.on_log_scale","title":"on_log_scale","text":"<pre><code>on_log_scale(state)\n</code></pre> <p>Toggle logarithmic scaling for the histogram and refresh.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>The state of the checkbox (Qt.Checked or Qt.Unchecked).</p> required"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer","title":"NellieVisualizer","text":"<pre><code>NellieVisualizer(napari_viewer, nellie, parent=None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>The NellieVisualizer class provides an interface for visualizing different stages of the Nellie pipeline, such as raw images, preprocessed images, segmentation labels, mocap markers, and reassigned labels. It also enables track visualization for specific labels and all frame labels using napari.</p> <p>Initialize the NellieVisualizer class, setting up buttons and layout for opening and visualizing images and tracks.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> required <code>nellie</code> <code>object</code> <p>Reference to the Nellie instance managing the pipeline.</p> required <code>parent</code> <code>QWidget</code> <p>Optional parent widget (default is None).</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.set_ui","title":"set_ui","text":"<pre><code>set_ui()\n</code></pre> <p>Initialize and set the layout and UI components for the NellieVisualizer. It groups the buttons for image and track visualization into separate sections and arranges them within a vertical layout.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.post_init","title":"post_init","text":"<pre><code>post_init()\n</code></pre> <p>Post-initialization method that sets the image scale based on the image resolution, makes the scale bar visible, and updates button enabled states based on existing files.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.check_3d","title":"check_3d","text":"<pre><code>check_3d()\n</code></pre> <p>Ensure that the napari viewer is in 3D display mode if the dataset contains Z-dimension data.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.set_scale","title":"set_scale","text":"<pre><code>set_scale()\n</code></pre> <p>Set the scale for image display based on the resolution of the Z, Y, and X dimensions of the image.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.open_preprocess_image","title":"open_preprocess_image","text":"<pre><code>open_preprocess_image()\n</code></pre> <p>Open and display the preprocessed (Frangi-filtered) image in the napari viewer. Reuses an existing layer if it has already been created.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.open_segment_image","title":"open_segment_image","text":"<pre><code>open_segment_image()\n</code></pre> <p>Open and display the segmentation labels (skeleton relabeled and instance labels) in the napari viewer. Reuses existing layers if they have already been created.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.on_track_selected","title":"on_track_selected","text":"<pre><code>on_track_selected()\n</code></pre> <p>Visualize the tracks for the currently selected label in the napari viewer, based on the active image layer.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.track_all","title":"track_all","text":"<pre><code>track_all()\n</code></pre> <p>Visualize tracks for all labels across frames in the napari viewer, based on the active image layer.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.open_mocap_image","title":"open_mocap_image","text":"<pre><code>open_mocap_image()\n</code></pre> <p>Open and display the mocap marker image in the napari viewer. Reuses an existing layer if it has already been created.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.open_reassign_image","title":"open_reassign_image","text":"<pre><code>open_reassign_image()\n</code></pre> <p>Open and display the reassigned branch and object labels in the napari viewer. Reuses existing layers if they have already been created.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.open_raw","title":"open_raw","text":"<pre><code>open_raw()\n</code></pre> <p>Open and display the raw image in the napari viewer. Reuses an existing layer if it has already been created.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieVisualizer.check_file_existence","title":"check_file_existence","text":"<pre><code>check_file_existence()\n</code></pre> <p>Check for the existence of files related to different steps of the pipeline, enabling or disabling buttons accordingly.</p>"},{"location":"api/nellie_napari/#nellie_napari.Settings","title":"Settings","text":"<pre><code>Settings(napari_viewer, nellie, parent=None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>The Settings class provides a user interface for configuring various options and settings for the Nellie pipeline and visualizations. Users can enable or disable specific processing options, control track visualization settings, and configure voxel visualization parameters.</p> <p>Initialize the Settings class, setting up the user interface and options for configuring processing and track visualization.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> required <code>nellie</code> <code>object</code> <p>Reference to the Nellie instance that manages the pipeline.</p> required <code>parent</code> <code>QWidget</code> <p>Optional parent widget (default is None).</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.Settings.post_init","title":"post_init","text":"<pre><code>post_init()\n</code></pre> <p>Post-initialization method that sets the initialized flag to True.</p> <p>This can be called by the plugin infrastructure once all external components are set up and the Settings widget is fully integrated.</p>"},{"location":"api/nellie_napari/#nellie_napari.Settings.set_ui","title":"set_ui","text":"<pre><code>set_ui()\n</code></pre> <p>Initialize and set the layout and UI components for the Settings class. This includes checkboxes for configuring the processing pipeline and track visualization options, as well as advanced per-step parameters.</p>"},{"location":"api/nellie_napari/#nellie_napari.Settings.to_config","title":"to_config","text":"<pre><code>to_config()\n</code></pre> <p>Return the current UI state as a SettingsConfig dataclass.</p> <p>Returns:</p> Type Description <code>SettingsConfig</code> <p>Dataclass capturing the current configuration of the settings widget.</p>"},{"location":"api/nellie_napari/#nellie_napari.Settings.apply_config","title":"apply_config","text":"<pre><code>apply_config(config)\n</code></pre> <p>Apply a SettingsConfig instance to the UI.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SettingsConfig</code> <p>Configuration to apply to the UI.</p> required"},{"location":"api/nellie_napari/#nellie_napari.Home","title":"Home","text":"<pre><code>Home(napari_viewer, nellie, parent=None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>The Home screen for the Nellie application, displayed in the napari viewer. It provides options to start using the application, navigate to the file selection tab, and take screenshots.</p> <p>Attributes:</p> Name Type Description <code>viewer</code> <code>Viewer</code> <p>The napari viewer instance.</p> <code>nellie</code> <code>object</code> <p>Reference to the main Nellie object containing image processing pipelines and functions.</p> <code>layout</code> <code>QVBoxLayout</code> <p>The vertical layout to organize the widgets on the home screen.</p> <code>start_button</code> <code>QPushButton</code> <p>Button to start the application and navigate to the file selection tab.</p> <code>screenshot_button</code> <code>QPushButton</code> <p>Button to take a screenshot of the current napari viewer canvas.</p> <p>Methods:</p> Name Description <code>set_update_status</code> <p>Updates the label that reports the version / update status.</p> <code>screenshot</code> <p>Takes a screenshot of the napari viewer and saves it to a specified folder.</p> <p>Initialize the Home screen with a logo, title, description, and buttons for navigation and screenshot functionality.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> required <code>nellie</code> <code>object</code> <p>Reference to the main Nellie object containing image processing pipelines and functions.</p> required <code>parent</code> <code>QWidget</code> <p>Optional parent widget (default is None).</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.Home.set_update_status","title":"set_update_status","text":"<pre><code>set_update_status()\n</code></pre> <p>Check if the plugin is up to date by comparing the installed version with the latest version on PyPI. If an update is available, it displays a warning to the user.</p>"},{"location":"api/nellie_napari/#nellie_napari.Home.screenshot","title":"screenshot","text":"<pre><code>screenshot(checked=False)\n</code></pre> <p>Take a screenshot of the napari viewer and saves it as a PNG file in a specified folder.</p> <p>Parameters:</p> Name Type Description Default <code>checked</code> <code>bool</code> <p>Parameter provided by the QPushButton clicked signal. Ignored.</p> <code>False</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect","title":"NellieFileSelect","text":"<pre><code>NellieFileSelect(napari_viewer, nellie, parent=None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A class for selecting and configuring image files for processing in the Nellie pipeline within the napari viewer.</p> <p>Attributes:</p> Name Type Description <code>viewer</code> <code>Viewer</code> <p>The napari viewer instance.</p> <code>nellie</code> <code>object</code> <p>Reference to the main Nellie object containing image processing pipelines and functions.</p> <code>filepath</code> <code>str or None</code> <p>The selected file or folder path.</p> <code>file_info</code> <code>FileInfo or None</code> <p>Stores metadata and shape information about the currently active image file.</p> <code>im_info</code> <code>ImInfo or list[ImInfo] or None</code> <p>Information object(s) for the image file(s) after confirmation / OME-TIFF creation.</p> <code>batch_fileinfo_list</code> <code>list[FileInfo] or None</code> <p>List of FileInfo objects when a folder is selected for batch processing.</p> <code>filepath_text</code> <code>QLabel</code> <p>Text widget displaying the selected file or folder path.</p> <code>filepath_button</code> <code>QPushButton</code> <p>Button to open the file dialog for selecting an image file.</p> <code>folder_button</code> <code>QPushButton</code> <p>Button to open the folder dialog for batch processing.</p> <code>reset_button</code> <code>QPushButton</code> <p>Button to reset the file selection and clear all settings (via nellie.reset()).</p> <code>file_shape_text</code> <code>QLabel</code> <p>Displays the shape of the selected image file.</p> <code>current_order_text</code> <code>QLabel</code> <p>Displays the current dimension order (axes) of the image file.</p> <code>dim_order_button</code> <code>QLineEdit</code> <p>Input field for entering the dimension order of the image.</p> <code>dim_t_button, dim_z_button, dim_xy_button</code> <code>QLineEdit</code> <p>Input fields for entering the resolution of the time (T), Z, and XY dimensions, respectively.</p> <code>channel_button</code> <code>QSpinBox</code> <p>Spin box for selecting the channel in the multi-channel image (0-based index).</p> <code>start_frame_button, end_frame_button</code> <code>QSpinBox</code> <p>Spin boxes for selecting the start and end frame (0-based indices) for temporal range selection.</p> <code>confirm_button</code> <code>QPushButton</code> <p>Button to confirm the file selection and save the OME-TIFF file(s).</p> <code>preview_button</code> <code>QPushButton</code> <p>Button to preview the image in the napari viewer.</p> <code>process_button</code> <code>QPushButton</code> <p>Button to process the selected image file(s) through the Nellie pipeline.</p> <p>Initialize the NellieFileSelect class.</p> <p>Parameters:</p> Name Type Description Default <code>napari_viewer</code> <code>Viewer</code> <p>Reference to the napari viewer instance.</p> required <code>nellie</code> <code>object</code> <p>Reference to the main Nellie object containing image processing pipelines and functions.</p> required <code>parent</code> <code>QWidget</code> <p>Optional parent widget (default is None).</p> <code>None</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.init_ui","title":"init_ui","text":"<pre><code>init_ui()\n</code></pre> <p>Set up the user interface layout with sections for file selection, axes information, dimension resolutions, slice settings, and action buttons.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.select_filepath","title":"select_filepath","text":"<pre><code>select_filepath()\n</code></pre> <p>Open a file dialog for selecting an image file, validates the selected file, and updates the UI with metadata.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.select_folder","title":"select_folder","text":"<pre><code>select_folder()\n</code></pre> <p>Open a folder dialog for selecting a folder for batch processing and initializes FileInfo objects for all files in the folder.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.validate_path","title":"validate_path","text":"<pre><code>validate_path(filepath)\n</code></pre> <p>Validate the selected file or folder path and updates the file path attribute. Canceling the dialog is treated as a no-op.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The file or folder path selected by the user.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a valid path was selected, False otherwise.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.initialize_single_file","title":"initialize_single_file","text":"<pre><code>initialize_single_file(metadata_already_loaded=False, reset_overrides=False)\n</code></pre> <p>Initialize the FileInfo object for the selected image file, loads metadata, and updates the dimension resolution fields.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_already_loaded</code> <code>bool</code> <p>If True, skip calling find_metadata/load_metadata (used for batch initialization where metadata was already loaded).</p> <code>False</code> <code>reset_overrides</code> <code>bool</code> <p>If True, clear any user-entered overrides so metadata-derived values are used for the new selection.</p> <code>False</code>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.initialize_folder","title":"initialize_folder","text":"<pre><code>initialize_folder()\n</code></pre> <p>Initialize FileInfo objects for all .tif, .tiff, and .nd2 files in the selected folder and loads their metadata.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one compatible file was found and initialized, False otherwise.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.on_change","title":"on_change","text":"<pre><code>on_change()\n</code></pre> <p>Update the user interface elements, including enabling or disabling buttons based on the file metadata and resolution settings.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.check_available_dims","title":"check_available_dims","text":"<pre><code>check_available_dims()\n</code></pre> <p>Check the availability of specific dimensions (T, Z, XY) in the selected file and enables the corresponding input fields for resolutions.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.handle_dim_order_changed","title":"handle_dim_order_changed","text":"<pre><code>handle_dim_order_changed()\n</code></pre> <p>Handle changes in the dimension order input field and updates the FileInfo object(s) accordingly.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.handle_axes_combo_changed","title":"handle_axes_combo_changed","text":"<pre><code>handle_axes_combo_changed(_text)\n</code></pre> <p>Handle axes updates from the combo boxes.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.handle_t_changed","title":"handle_t_changed","text":"<pre><code>handle_t_changed()\n</code></pre> <p>Handle changes in the time (T) resolution input field and updates the FileInfo object(s) accordingly.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.handle_z_changed","title":"handle_z_changed","text":"<pre><code>handle_z_changed()\n</code></pre> <p>Handle changes in the Z resolution input field and updates the FileInfo object(s) accordingly.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.handle_xy_changed","title":"handle_xy_changed","text":"<pre><code>handle_xy_changed()\n</code></pre> <p>Handle changes in the XY resolution input field and updates the FileInfo object(s) accordingly.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.change_channel","title":"change_channel","text":"<pre><code>change_channel()\n</code></pre> <p>Update the selected channel in the FileInfo object(s) when the channel spin box value is changed.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.change_time","title":"change_time","text":"<pre><code>change_time()\n</code></pre> <p>Update the temporal range in the FileInfo object(s) when the start or end frame spin box values are changed.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.on_confirm","title":"on_confirm","text":"<pre><code>on_confirm()\n</code></pre> <p>Confirm the file selection, creates ImInfo object(s) for the file(s), and prepares them for processing (creating OME-TIFF files).</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.on_process","title":"on_process","text":"<pre><code>on_process()\n</code></pre> <p>Prepare the selected file(s) for processing through the Nellie pipeline by creating ImInfo object(s) and switching to the processing tab.</p>"},{"location":"api/nellie_napari/#nellie_napari.NellieFileSelect.on_preview","title":"on_preview","text":"<pre><code>on_preview()\n</code></pre> <p>Open a preview of the selected image in the napari viewer, adjusting display settings (e.g., 2D or 3D view) based on the file's dimensionality.</p>"},{"location":"api/run/","title":"Main Interface","text":"<p>The main entry point for running the Nellie pipeline.</p>"},{"location":"api/run/#nellie.run","title":"run","text":"<p>Main entry point for the Nellie image analysis pipeline.</p> <p>This module provides the run function, which orchestrates the complete Nellie pipeline including filtering, segmentation, tracking, and feature extraction.</p>"},{"location":"api/run/#nellie.run.run","title":"run","text":"<pre><code>run(file_info, remove_edges=False, otsu_thresh_intensity=False, threshold=None, timeit=False, device='auto', low_memory=False)\n</code></pre> <p>Main entry point for the Nellie pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>file_info</code> <code>FileInfo</code> <p>FileInfo object containing metadata about the input image.</p> required <code>remove_edges</code> <code>bool</code> <p>Whether to remove edges during filtering (default is False).</p> <code>False</code> <code>otsu_thresh_intensity</code> <code>bool</code> <p>Whether to use Otsu thresholding for intensity (default is False).</p> <code>False</code> <code>threshold</code> <code>float</code> <p>Manual threshold value (default is None).</p> <code>None</code> <code>timeit</code> <code>bool</code> <p>Whether to time each step of the pipeline (default is False).</p> <code>False</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection for preprocessing, labeling, and feature extraction.</p> <code>\"auto\"</code> <code>low_memory</code> <code>bool</code> <p>Whether to prefer lower-memory (slower) implementations where available.</p> <code>False</code> <p>Returns:</p> Type Description <code>ImInfo</code> <p>ImInfo object containing processed image data and paths.</p>"},{"location":"api/segmentation/","title":"Segmentation","text":"<p>Image segmentation modules for filtering, labeling, marker detection, and network analysis.</p>"},{"location":"api/segmentation/#filtering","title":"Filtering","text":"<p>Multi-scale Frangi filtering for detecting vesselness and tubular structures.</p>"},{"location":"api/segmentation/#nellie.segmentation.filtering","title":"filtering","text":"<p>Frangi-like vesselness filter for 3D/4D microscopy image data.</p> <p>This module provides the Filter class, which implements a multi-scale Frangi filtering approach optimized for large datasets with optional GPU acceleration.</p>"},{"location":"api/segmentation/#nellie.segmentation.filtering.Filter","title":"Filter","text":"<pre><code>Filter(im_info, num_t=None, remove_edges=False, min_radius_um=0.25, max_radius_um=1.0, alpha_sq=0.5, beta_sq=0.5, frob_thresh=None, frob_thresh_division=2, viewer=None, device='auto', low_memory=False, max_chunk_voxels=int(1000000.0), max_threshold_samples=int(1000000.0))\n</code></pre> <p>Frangi-like vesselness filter for 3D or 4D microscopy image data, optimized for large datasets and optional GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>Image metadata and file paths.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints to process. If None, inferred from image.</p> <code>None</code> <code>remove_edges</code> <code>bool</code> <p>If True, aggressively zero out bounding-box edges.</p> <code>False</code> <code>min_radius_um</code> <code>float</code> <p>Expected structure radius range in micrometers.</p> <code>0.25</code> <code>max_radius_um</code> <code>float</code> <p>Expected structure radius range in micrometers.</p> <code>0.25</code> <code>alpha_sq</code> <code>float</code> <p>Frangi parameters controlling sensitivity to blobness and plate-likeness.</p> <code>0.5</code> <code>beta_sq</code> <code>float</code> <p>Frangi parameters controlling sensitivity to blobness and plate-likeness.</p> <code>0.5</code> <code>frob_thresh</code> <code>float or None</code> <p>If given, fixed Frobenius norm threshold. Otherwise auto-estimated.</p> <code>None</code> <code>viewer</code> <code>object or None</code> <p>Optional GUI viewer with a <code>.status</code> attribute.</p> <code>None</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection. \"auto\" uses GPU if available, otherwise CPU. \"cpu\" forces NumPy/Scipy, and \"gpu\" forces CuPy/CuPyX (error if unavailable).</p> <code>\"auto\"</code> <code>low_memory</code> <code>bool</code> <p>If True, prefer strategies that reduce peak memory at the cost of speed (e.g. smaller eigen-decomposition chunks).</p> <code>False</code> <code>max_chunk_voxels</code> <code>int</code> <p>Maximum number of voxels per processing chunk and eigen-decomposition chunk.</p> <code>int(1000000.0)</code> <code>max_threshold_samples</code> <code>int</code> <p>Maximum number of samples to use when estimating thresholds (triangle / Otsu) from very large arrays.</p> <code>int(1000000.0)</code>"},{"location":"api/segmentation/#nellie.segmentation.filtering.Filter.run","title":"run","text":"<pre><code>run(mask=True)\n</code></pre> <p>Main entry point: run the Frangi filter over the image.</p>"},{"location":"api/segmentation/#labelling","title":"Labelling","text":"<p>Threshold-based semantic and instance segmentation.</p>"},{"location":"api/segmentation/#nellie.segmentation.labelling","title":"labelling","text":"<p>Semantic and instance segmentation for microscopy images.</p> <p>This module provides the Label class for thresholding-based segmentation with optimizations for large volumes and optional GPU acceleration.</p>"},{"location":"api/segmentation/#nellie.segmentation.labelling.Label","title":"Label","text":"<pre><code>Label(im_info, num_t=None, threshold=None, otsu_thresh_intensity=False, viewer=None, chunk_z=None, flush_interval=1, min_radius_um=0.25, threshold_sampling_pixels=1000000, histogram_nbins=256, device='auto', low_memory=False, max_chunk_voxels=int(1000000.0))\n</code></pre> <p>A class for semantic and instance segmentation of microscopy images using thresholding techniques, optimized for large volumes and optional GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>Image metadata and paths.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints to process.</p> <code>None</code> <code>threshold</code> <code>float or None</code> <p>Fixed intensity threshold for segmentation (if not using Otsu).</p> <code>None</code> <code>otsu_thresh_intensity</code> <code>bool</code> <p>Whether to apply Otsu's method for intensity thresholding.</p> <code>False</code> <code>viewer</code> <code>object or None</code> <p>Viewer object for displaying status.</p> <code>None</code> <code>chunk_z</code> <code>int or None</code> <p>If not None and image has Z, process each timepoint in Z-chunks of this size instead of the full volume. If None and low_memory is True, a chunk size is inferred from max_chunk_voxels.</p> <code>None</code> <code>flush_interval</code> <code>int</code> <p>How often (in frames) to flush the output memmap to disk.</p> <code>1</code> <code>min_radius_um</code> <code>float</code> <p>Minimum expected object radius in micrometers. Labels smaller than the area/volume of a circle/sphere with this radius are removed.</p> <code>0.25</code> <code>threshold_sampling_pixels</code> <code>int</code> <p>Maximum number of pixels sampled when computing global thresholds to reduce histogram cost for very large volumes.</p> <code>1000000</code> <code>histogram_nbins</code> <code>int</code> <p>Number of bins to use in histogram-based thresholding.</p> <code>256</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection. \"auto\" uses GPU if available, otherwise CPU.</p> <code>\"auto\"</code> <code>low_memory</code> <code>bool</code> <p>If True, prefer chunked Z processing to reduce peak memory usage.</p> <code>False</code> <code>max_chunk_voxels</code> <code>int</code> <p>Target maximum number of voxels per Z-chunk when low_memory is True and chunk_z is not specified.</p> <code>int(1000000.0)</code>"},{"location":"api/segmentation/#nellie.segmentation.labelling.Label.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main method to execute the full segmentation process over the image data.</p>"},{"location":"api/segmentation/#mocap-marking","title":"Mocap Marking","text":"<p>Motion capture marker detection using distance transforms and multi-scale peak detection.</p>"},{"location":"api/segmentation/#nellie.segmentation.mocap_marking","title":"mocap_marking","text":"<p>Motion capture marker generation for microscopy images.</p> <p>This module provides the Markers class for detecting and marking key points in segmented structures using distance transforms and multi-scale peak detection.</p> Notes <ul> <li>Distance and border outputs are always saved because downstream steps depend on them.</li> <li>The border mask is the outside shell, computed as dilation(mask) XOR mask.</li> </ul>"},{"location":"api/segmentation/#nellie.segmentation.mocap_marking.Markers","title":"Markers","text":"<pre><code>Markers(im_info, num_t=None, min_radius_um=0.2, max_radius_um=1, use_im='distance', num_sigma=5, viewer=None, prefer_gpu=True, peak_min_distance=2, device='auto', low_memory=False, max_chunk_voxels=int(1000000.0))\n</code></pre> <p>A class for generating motion capture markers in microscopy images using distance transforms and peak detection.</p> <p>Optimizations: - Uses distance_transform_edt instead of KD-tree for distance transform. - Streams over scales for LoG (no large 4D arrays). - Uses morphological non-max suppression instead of KD-tree for peak pruning. - Supports GPU via CuPy/CuPyX with automatic fallback to CPU on OOM. - Optional low-memory chunking for LoG and NMS while preserving results.</p> <p>Attributes:</p> Name Type Description <code>im_info</code> <code>ImInfo</code> <p>An object containing image metadata and memory-mapped image data.</p> <code>num_t</code> <code>int</code> <p>Number of timepoints in the image.</p> <code>min_radius_um</code> <code>float</code> <p>Minimum radius of detected objects in micrometers.</p> <code>max_radius_um</code> <code>float</code> <p>Maximum radius of detected objects in micrometers.</p> <code>min_radius_px</code> <code>float</code> <p>Minimum radius of detected objects in pixels.</p> <code>max_radius_px</code> <code>float</code> <p>Maximum radius of detected objects in pixels.</p> <code>use_im</code> <code>str</code> <p>Specifies which image to use for peak detection ('distance' or 'frangi').</p> <code>num_sigma</code> <code>int</code> <p>Number of sigma steps for multi-scale filtering.</p> <code>shape</code> <code>tuple</code> <p>Shape of the input image.</p> <code>im_memmap</code> <code>ndarray or None</code> <p>Memory-mapped original image data.</p> <code>im_frangi_memmap</code> <code>ndarray or None</code> <p>Memory-mapped Frangi-filtered image data.</p> <code>label_memmap</code> <code>ndarray or None</code> <p>Memory-mapped label data from instance segmentation.</p> <code>im_marker_memmap</code> <code>ndarray or None</code> <p>Memory-mapped output for motion capture markers.</p> <code>im_distance_memmap</code> <code>ndarray or None</code> <p>Memory-mapped output for distance transform.</p> <code>im_border_memmap</code> <code>ndarray or None</code> <p>Memory-mapped output for image borders.</p> <code>debug</code> <code>dict or None</code> <p>Debugging information for tracking the marking process.</p> <code>viewer</code> <code>object or None</code> <p>Viewer object for displaying status during processing.</p> <code>device</code> <code>{auto, cpu, gpu}</code> <p>Backend selection. \"auto\" uses GPU if available, otherwise CPU.</p> <code>low_memory</code> <code>bool</code> <p>If True, prefer chunked LoG and NMS to reduce peak memory at the cost of speed.</p> <code>max_chunk_voxels</code> <code>int</code> <p>Maximum voxels per chunk when low-memory mode is used.</p> <code>use_gpu</code> <code>bool</code> <p>Whether to use the GPU backend (if available). Automatically set to False on GPU OOM.</p> <code>peak_min_distance</code> <code>int</code> <p>Minimum separation (in pixels) between peaks in morphological NMS.</p> <p>Initializes the Markers object with image metadata and marking parameters.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>An instance of the ImInfo class, containing metadata and paths for the image file.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints to process. If None, defaults to the number of timepoints in the image.</p> <code>None</code> <code>min_radius_um</code> <code>float</code> <p>Minimum radius of detected objects in micrometers (default is 0.20).</p> <code>0.2</code> <code>max_radius_um</code> <code>float</code> <p>Maximum radius of detected objects in micrometers (default is 1).</p> <code>1</code> <code>use_im</code> <code>str</code> <p>Specifies which image to use for peak detection ('distance' or 'frangi', default is 'distance').</p> <code>'distance'</code> <code>num_sigma</code> <code>int</code> <p>Number of sigma steps for multi-scale filtering (default is 5).</p> <code>5</code> <code>viewer</code> <code>object or None</code> <p>Viewer object for displaying status during processing (default is None).</p> <code>None</code> <code>prefer_gpu</code> <code>bool</code> <p>Whether to prefer GPU backend when available (default is True).</p> <code>True</code> <code>peak_min_distance</code> <code>int</code> <p>Minimum distance (in pixels) between peaks for NMS (default is 2).</p> <code>2</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection. \"auto\" uses GPU if available, otherwise CPU.</p> <code>\"auto\"</code> <code>low_memory</code> <code>bool</code> <p>If True, prefer chunked LoG and NMS to reduce memory at the cost of speed.</p> <code>False</code> <code>max_chunk_voxels</code> <code>int</code> <p>Maximum number of voxels per chunk for low-memory processing.</p> <code>int(1000000.0)</code>"},{"location":"api/segmentation/#nellie.segmentation.mocap_marking.Markers.xp","title":"xp  <code>property</code>","text":"<pre><code>xp\n</code></pre> <p>Array module for the current backend.</p>"},{"location":"api/segmentation/#nellie.segmentation.mocap_marking.Markers.ndi_backend","title":"ndi_backend  <code>property</code>","text":"<pre><code>ndi_backend\n</code></pre> <p>Ndimage backend for the current backend.</p>"},{"location":"api/segmentation/#nellie.segmentation.mocap_marking.Markers.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main method to execute the motion capture marking process over the image data.</p> <p>This method allocates memory, sets sigma values, and runs the marking process for all timepoints.</p>"},{"location":"api/segmentation/#networking","title":"Networking","text":"<p>Network skeletonization and topological analysis.</p>"},{"location":"api/segmentation/#nellie.segmentation.networking","title":"networking","text":"<p>Network skeletonization and analysis for microscopy images.</p> <p>This module provides the Network class for skeletonizing network-like structures and analyzing their topology with optimized CPU/GPU processing.</p>"},{"location":"api/segmentation/#nellie.segmentation.networking.Network","title":"Network","text":"<pre><code>Network(im_info, num_t=None, min_radius_um=0.2, max_radius_um=1, viewer=None, device='auto', low_memory=False, max_chunk_voxels=int(1000000.0))\n</code></pre> <p>Optimized class for analyzing and skeletonizing network-like structures in 3D or 4D microscopy images.</p> <p>This version focuses on:   - Reduced CPU/GPU thrashing.   - Vectorized neighborhood operations (no Python per-voxel loops on large arrays).   - More memory-friendly local-max detection.   - More efficient branch relabeling using distance transforms on per-object crops.   - Graceful degradation when GPU memory is insufficient (CPU/chunked fallback).</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>Image metadata and paths.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints to process. Defaults to all timepoints.</p> <code>None</code> <code>min_radius_um</code> <code>float</code> <p>Minimum radius of detected objects in micrometers.</p> <code>0.2</code> <code>max_radius_um</code> <code>float</code> <p>Maximum radius of detected objects in micrometers.</p> <code>1</code> <code>viewer</code> <code>object or None</code> <p>Viewer object for status reporting.</p> <code>None</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection for connectivity computations.</p> <code>\"auto\"</code> <code>low_memory</code> <code>bool</code> <p>If True, use chunked CPU fallbacks for local neighborhood operations.</p> <code>False</code> <code>max_chunk_voxels</code> <code>int</code> <p>Maximum voxels per chunk for low-memory paths.</p> <code>int(1000000.0)</code>"},{"location":"api/segmentation/#nellie.segmentation.networking.Network.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Execute the full network analysis pipeline.</p>"},{"location":"api/tracking/","title":"Tracking","text":"<p>Temporal tracking modules for object tracking across timepoints.</p>"},{"location":"api/tracking/#label-tracking","title":"Label Tracking","text":"<p>Track labeled objects across timepoints using flow interpolation.</p>"},{"location":"api/tracking/#nellie.tracking.all_tracks_for_label","title":"all_tracks_for_label","text":"<p>Label tracking across timepoints using flow interpolation.</p> <p>This module provides the LabelTracks class for tracking labeled objects over time using forward and backward flow interpolation.</p>"},{"location":"api/tracking/#nellie.tracking.all_tracks_for_label.LabelTracks","title":"LabelTracks","text":"<pre><code>LabelTracks(im_info, num_t=None, label_im_path=None)\n</code></pre> <p>A class to track labeled objects over multiple timepoints in a microscopy image using flow interpolation.</p> <p>Attributes:</p> Name Type Description <code>im_info</code> <code>ImInfo</code> <p>An object containing image metadata and memory-mapped image data.</p> <code>num_t</code> <code>int</code> <p>Number of timepoints in the image.</p> <code>label_im_path</code> <code>str</code> <p>Path to the labeled instance image.</p> <code>im_memmap</code> <code>ndarray or None</code> <p>Memory-mapped original image data.</p> <code>label_memmap</code> <code>ndarray or None</code> <p>Memory-mapped labeled instance image data.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes memory-mapped data for both the raw image and the labeled instance image.</p> <code>run</code> <p>Runs the tracking process for labeled objects across timepoints, both forward and backward.</p> <p>Initializes the LabelTracks class with image metadata, timepoints, and label image path.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>An instance of the ImInfo class containing image metadata and paths.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints in the image (default is None, in which case it is inferred from the image metadata).</p> <code>None</code> <code>label_im_path</code> <code>str</code> <p>Path to the labeled instance image. If not provided, defaults to the 'im_instance_label' path in <code>im_info</code>.</p> <code>None</code>"},{"location":"api/tracking/#nellie.tracking.all_tracks_for_label.LabelTracks.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initializes memory-mapped data for both the raw image and the labeled instance image.</p> <p>This method prepares the image data and the labeled data for processing, mapping them into memory.</p>"},{"location":"api/tracking/#nellie.tracking.all_tracks_for_label.LabelTracks.run","title":"run","text":"<pre><code>run(label_num=None, start_frame=0, end_frame=None, min_track_num=0, skip_coords=1, max_distance_um=0.5)\n</code></pre> <p>Runs the tracking process for labeled objects across timepoints, using flow interpolation.</p> <p>This method uses forward and backward interpolation to track objects across multiple frames, starting from a given frame. It can also track specific labels or all labels in the image.</p> <p>Parameters:</p> Name Type Description Default <code>label_num</code> <code>int</code> <p>Label number to track. If None, all labels are tracked (default is None).</p> <code>None</code> <code>start_frame</code> <code>int</code> <p>The starting frame from which to begin tracking (default is 0).</p> <code>0</code> <code>end_frame</code> <code>int</code> <p>The ending frame for the tracking. If None, tracks until the last frame (default is None).</p> <code>None</code> <code>min_track_num</code> <code>int</code> <p>Minimum track number to assign to the coordinates (default is 0).</p> <code>0</code> <code>skip_coords</code> <code>int</code> <p>The interval at which coordinates are sampled (default is 1).</p> <code>1</code> <code>max_distance_um</code> <code>float</code> <p>Maximum distance allowed for interpolation (in micrometers, default is 0.5).</p> <code>0.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A list of tracks and a dictionary of track properties.</p>"},{"location":"api/tracking/#flow-interpolation","title":"Flow Interpolation","text":"<p>Optical flow vector interpolation for temporal tracking.</p>"},{"location":"api/tracking/#nellie.tracking.flow_interpolation","title":"flow_interpolation","text":"<p>Flow vector interpolation for temporal tracking in microscopy images.</p> <p>This module provides interpolation of optical flow vectors between timepoints with optimizations for large datasets and optional GPU acceleration.</p>"},{"location":"api/tracking/#nellie.tracking.flow_interpolation.FlowInterpolator","title":"FlowInterpolator","text":"<pre><code>FlowInterpolator(im_info, num_t=None, max_distance_um=0.5, forward=True)\n</code></pre> <p>A class for interpolating flow vectors between timepoints in microscopy images using precomputed flow data.</p> <p>Attributes:</p> Name Type Description <code>im_info</code> <code>ImInfo</code> <p>An object containing image metadata and memory-mapped image data.</p> <code>num_t</code> <code>int</code> <p>Number of timepoints in the image.</p> <code>max_distance_um</code> <code>float</code> <p>Maximum distance allowed for interpolation (in micrometers).</p> <code>forward</code> <code>bool</code> <p>Indicates if the interpolation is performed in the forward direction (True) or backward direction (False).</p> <code>scaling</code> <code>tuple</code> <p>Scaling factors for Z, Y, and X dimensions.</p> <code>shape</code> <code>tuple</code> <p>Shape of the input image.</p> <code>im_memmap</code> <code>ndarray or None</code> <p>Memory-mapped original image data.</p> <code>flow_vector_array</code> <code>ndarray or None</code> <p>Precomputed flow vector array loaded from disk.</p> <code>current_t</code> <code>int or None</code> <p>Cached timepoint for the current flow vector calculation.</p> <code>check_rows</code> <code>ndarray or None</code> <p>Flow vector data for the current timepoint.</p> <code>check_coords</code> <code>ndarray or None</code> <p>Coordinates corresponding to the flow vector data for the current timepoint.</p> <code>current_tree</code> <code>cKDTree or None</code> <p>KDTree for fast lookup of nearby coordinates in the current timepoint.</p> <code>debug</code> <code>dict or None</code> <p>Debugging information for tracking processing steps.</p> <p>Methods:</p> Name Description <code>_allocate_memory</code> <p>Allocates memory and loads the precomputed flow vector array.</p> <code>_get_t</code> <p>Determines the number of timepoints to process.</p> <code>_get_nearby_coords</code> <p>Finds nearby coordinates within a defined radius from the given coordinates using a KDTree.</p> <code>_get_vector_weights</code> <p>Computes the weights for nearby flow vectors based on their distances and costs.</p> <code>_get_final_vector</code> <p>Computes the final interpolated vector for each coordinate using distance-weighted vectors.</p> <code>interpolate_coord</code> <p>Interpolates the flow vector at the given coordinates and timepoint.</p> <code>_initialize</code> <p>Initializes the FlowInterpolator by allocating memory and setting the timepoints.</p> <p>Initializes the FlowInterpolator with image metadata and interpolation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>An instance of the ImInfo class, containing metadata and paths for the image file.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints to process. If None, defaults to the number of timepoints in the image.</p> <code>None</code> <code>max_distance_um</code> <code>float</code> <p>Maximum distance allowed for interpolation (in micrometers, default is 0.5).</p> <code>0.5</code> <code>forward</code> <code>bool</code> <p>Indicates if the interpolation is performed in the forward direction (default is True).</p> <code>True</code>"},{"location":"api/tracking/#nellie.tracking.flow_interpolation.FlowInterpolator.interpolate_coord","title":"interpolate_coord","text":"<pre><code>interpolate_coord(coords, t)\n</code></pre> <p>Interpolates the flow vector at the given coordinates and timepoint.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>Input coordinates for interpolation.</p> required <code>t</code> <code>int</code> <p>Timepoint index.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Interpolated flow vectors at the given coordinates and timepoint.</p>"},{"location":"api/tracking/#nellie.tracking.flow_interpolation.interpolate_all_forward","title":"interpolate_all_forward","text":"<pre><code>interpolate_all_forward(coords, start_t, end_t, im_info, min_track_num=0, max_distance_um=0.5)\n</code></pre> <p>Interpolates coordinates forward in time across multiple timepoints using flow vectors.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>Array of input coordinates to track.</p> required <code>start_t</code> <code>int</code> <p>Starting timepoint.</p> required <code>end_t</code> <code>int</code> <p>Ending timepoint.</p> required <code>im_info</code> <code>ImInfo</code> <p>An instance of the ImInfo class containing image metadata and paths.</p> required <code>min_track_num</code> <code>int</code> <p>Minimum track number to assign to coordinates (default is 0).</p> <code>0</code> <code>max_distance_um</code> <code>float</code> <p>Maximum distance allowed for interpolation (in micrometers, default is 0.5).</p> <code>0.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>List of tracks and associated track properties.</p>"},{"location":"api/tracking/#nellie.tracking.flow_interpolation.interpolate_all_backward","title":"interpolate_all_backward","text":"<pre><code>interpolate_all_backward(coords, start_t, end_t, im_info, min_track_num=0, max_distance_um=0.5)\n</code></pre> <p>Interpolates coordinates backward in time across multiple timepoints using flow vectors.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>Array of input coordinates to track.</p> required <code>start_t</code> <code>int</code> <p>Starting timepoint.</p> required <code>end_t</code> <code>int</code> <p>Ending timepoint.</p> required <code>im_info</code> <code>ImInfo</code> <p>An instance of the ImInfo class containing image metadata and paths.</p> required <code>min_track_num</code> <code>int</code> <p>Minimum track number to assign to coordinates (default is 0).</p> <code>0</code> <code>max_distance_um</code> <code>float</code> <p>Maximum distance allowed for interpolation (in micrometers, default is 0.5).</p> <code>0.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>List of tracks and associated track properties.</p>"},{"location":"api/tracking/#hu-moment-tracking","title":"Hu Moment Tracking","text":"<p>Hu moment-based tracking for robust object identification across frames.</p>"},{"location":"api/tracking/#nellie.tracking.hu_tracking","title":"hu_tracking","text":"<p>Hu moment-based tracking for labeled objects across timepoints.</p> <p>This module provides the HuMomentTracking class for tracking objects using Hu moment invariants and optical flow interpolation.</p>"},{"location":"api/tracking/#nellie.tracking.hu_tracking.HuMomentTracking","title":"HuMomentTracking","text":"<pre><code>HuMomentTracking(im_info, num_t=None, max_distance_um=1.0, viewer=None, device='auto', mode='auto', max_dense_pairs=int(10000000.0), max_dense_roi_voxels_cpu=int(50000000.0), max_dense_roi_voxels_gpu=int(20000000.0), low_memory=False)\n</code></pre> <p>A class for tracking objects in microscopy images using Hu moments and distance-based matching.</p> <p>This version is optimized for:   - Large images (memory-aware ROI extraction, streaming modes).   - Optional GPU acceleration (via CuPy).   - Fallback to sparse KDTree-based matching when dense matching is too large.</p> <p>Attributes:</p> Name Type Description <code>im_info</code> <code>ImInfo</code> <p>An object containing image metadata and memory-mapped image data.</p> <code>device</code> <code>{auto, cpu, gpu}</code> <p>Backend selection. \"auto\" uses GPU if available, otherwise CPU.</p> <code>device_type</code> <code>str</code> <p>Resolved backend type (\"cuda\" or \"cpu\").</p> <code>num_t</code> <code>int</code> <p>Number of timepoints in the image.</p> <code>max_distance_um</code> <code>float</code> <p>Maximum allowed velocity (micrometers/second), scaled by time resolution for per-frame distance.</p> <code>low_memory</code> <code>bool</code> <p>If True, prefer streaming ROI extraction and sparse matching to reduce peak memory.</p> <code>scaling</code> <code>tuple</code> <p>Scaling factors for Z, Y, and X dimensions.</p> <code>shape</code> <code>tuple</code> <p>Shape of the input image.</p> <code>im_memmap</code> <code>ndarray or None</code> <p>Memory-mapped original image data.</p> <code>im_frangi_memmap</code> <code>ndarray or None</code> <p>Memory-mapped Frangi-filtered image data.</p> <code>im_distance_memmap</code> <code>ndarray or None</code> <p>Memory-mapped distance transform data.</p> <code>im_marker_memmap</code> <code>ndarray or None</code> <p>Memory-mapped marker data for object tracking.</p> <code>flow_vector_array_path</code> <code>str or None</code> <p>Path to save the flow vector array.</p> Internal tuning parameters <p>mode : {\"auto\", \"dense\", \"sparse\"}     Matching mode. \"auto\" selects dense for small problems, sparse for large ones. max_dense_pairs : int     Maximum number of pairwise matches (N_post * N_pre) before switching to sparse matching. max_dense_roi_voxels_cpu : int     Rough upper bound on total ROI voxels for dense ROI extraction on CPU. max_dense_roi_voxels_gpu : int     Rough upper bound on total ROI voxels for dense ROI extraction on GPU.</p>"},{"location":"api/tracking/#nellie.tracking.hu_tracking.HuMomentTracking.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main method to execute the Hu moment-based tracking process over the image data.</p>"},{"location":"api/tracking/#voxel-reassignment","title":"Voxel Reassignment","text":"<p>Voxel-level tracking and label reassignment across timepoints.</p>"},{"location":"api/tracking/#nellie.tracking.voxel_reassignment","title":"voxel_reassignment","text":"<p>Voxel reassignment across timepoints using flow interpolation.</p> <p>This module provides the VoxelReassigner class for tracking and reassigning voxel labels across time using forward and backward flow interpolation.</p>"},{"location":"api/tracking/#nellie.tracking.voxel_reassignment.VoxelReassigner","title":"VoxelReassigner","text":"<pre><code>VoxelReassigner(im_info, num_t=None, viewer=None, store_running_matches=True, max_refine_iterations=3, device='auto', low_memory=False, max_query_points=int(1000000.0), max_bruteforce_pairs=int(10000000.0))\n</code></pre> <p>A class for voxel reassignment across time points using forward and backward flow interpolation.</p> <p>This optimized version:   - Streams over timepoints instead of holding all voxel coordinates in memory.   - Reuses a single set of voxel matches between timepoints for all label types.   - Avoids large intermediate dense arrays where possible.   - Optionally stores running matches for downstream analysis.   - Supports CPU/GPU matching with memory-aware chunking and fallbacks.   - Assigns labels using weighted votes from forward/backward interpolations.</p> <p>Parameters:</p> Name Type Description Default <code>im_info</code> <code>ImInfo</code> <p>Image metadata and memory-mapped data.</p> required <code>num_t</code> <code>int</code> <p>Number of timepoints in the dataset. If None, it is inferred from the image metadata.</p> <code>None</code> <code>viewer</code> <code>Any</code> <p>Optional viewer for visualization / status updates.</p> <code>None</code> <code>store_running_matches</code> <code>bool</code> <p>If True, store per-frame voxel matches (may be large for big datasets). Matches are stored as one best source per target voxel.</p> <code>True</code> <code>max_refine_iterations</code> <code>int</code> <p>Maximum number of vote iterations to assign labels at t+1 from t. Set to 1 for a single pass.</p> <code>3</code> <code>device</code> <code>(auto, cpu, gpu)</code> <p>Backend selection for nearest-neighbor matching.</p> <code>\"auto\"</code> <code>low_memory</code> <code>bool</code> <p>If True, prefer lower-memory matching strategies at the cost of speed.</p> <code>False</code> <code>max_query_points</code> <code>int</code> <p>Maximum number of points per KDTree query chunk.</p> <code>int(1000000.0)</code> <code>max_bruteforce_pairs</code> <code>int</code> <p>Maximum number of pairwise distances to compute in GPU brute-force mode.</p> <code>int(10000000.0)</code>"},{"location":"api/tracking/#nellie.tracking.voxel_reassignment.VoxelReassigner.match_voxels","title":"match_voxels","text":"<pre><code>match_voxels(vox_prev, vox_next, t)\n</code></pre> <p>Builds candidate voxel matches between two consecutive timepoints using both forward and backward interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>vox_prev</code> <code>ndarray</code> <p>Voxels from the previous timepoint (N0, D).</p> required <code>vox_next</code> <code>ndarray</code> <p>Voxels from the next timepoint (N1, D).</p> required <code>t</code> <code>int</code> <p>Current timepoint index.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>(candidate_prev, candidate_next, distances) where candidates include all valid forward/backward interpolated matches.</p>"},{"location":"api/tracking/#nellie.tracking.voxel_reassignment.VoxelReassigner.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main method to execute voxel reassignment for both branch and object labels.</p> <p>This implementation:   - initializes reassigned labels at t=0 for both branch and object labels.   - for each pair of consecutive timepoints, computes forward/backward     interpolation candidates once (based on the union of labeled voxels).   - assigns labels at t+1 using weighted votes from all candidates.</p>"},{"location":"api/utils/","title":"Utilities","text":"<p>Utility functions for logging and GPU/CPU operations.</p>"},{"location":"api/utils/#base-logger","title":"Base Logger","text":"<p>Logging configuration for the Nellie package.</p>"},{"location":"api/utils/#nellie.utils.base_logger","title":"base_logger","text":"<p>Configures the base logger for the Nellie package.</p>"},{"location":"api/utils/#gpu-functions","title":"GPU Functions","text":"<p>GPU/CPU-agnostic image thresholding functions.</p>"},{"location":"api/utils/#nellie.utils.gpu_functions","title":"gpu_functions","text":"<p>GPU/CPU-agnostic utility functions for image thresholding.</p> <p>This module provides implementations of Otsu and triangle thresholding methods that work with both NumPy (CPU) and CuPy (GPU) backends.</p>"},{"location":"api/utils/#nellie.utils.gpu_functions.otsu_threshold","title":"otsu_threshold","text":"<pre><code>otsu_threshold(matrix, nbins=256, xp=None)\n</code></pre> <p>GPU/CPU-agnostic implementation of Otsu's threshold. Operates on an n-d array using the current xp backend.</p>"},{"location":"api/utils/#nellie.utils.gpu_functions.triangle_threshold","title":"triangle_threshold","text":"<pre><code>triangle_threshold(matrix, nbins=256, xp=None)\n</code></pre> <p>GPU/CPU-agnostic implementation of triangle threshold. Operates on an n-d array using the current xp backend.</p>"}]}